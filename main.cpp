#include <SFML/Graphics.hpp>
#include <vector>
#include <cmath>
#include <algorithm>

const int WIDTH = 800; //4:3 ASPECT
const int HEIGHT = 600;
const float FOV = 60.0f;
const float NEAR_PLANE = 0.1f;

struct Vec3 {
	float x, y, z;
	Vec3 operator+(const Vec3& other) const {
		return {x + other.x, y + other.y, z + other.z};
	}
	Vec3 operator-(const Vec3& other) const {
		return {x - other.x, y - other.y, z - other.z};
	}
	Vec3 operator*(float s) const {
		return {x * s, y * s, z * s};
	}
	float dot(const Vec3& other) const {
		return x*other.x + y*other.y + z*other.z;
	}
};

struct Face {
	int a, b, c; //triangular projection
};

struct Mesh {
	std::vector<Vec3> verts; //vertices
	std::vector<Face> faces; 
};

Mesh tetrahedron(float size) { //will possibly import from external headers, in the future
	float s = size;
	Mesh mesh;
	mesh.verts = {                    //these coords have been generated by ChatGPT
		{ 0, 0, s},                  
		{ s, 0, -s / 2},             
		{-s, 0, -s / 2},             
		{ 0, s, 0}                   
	};
	mesh.faces = {
		{0, 1, 2},
		{0, 3, 1},
		{1, 3, 2},
		{2, 3, 0}
	};
	return mesh;
}


Vec3 rotateY(const Vec3& p, float angle) {
	float s = std::sin(angle);
	float c = std::cos(angle);
	return { //too much to break down here
		p.x * c - p.z * s,
			p.y,
			p.x * s + p.z * c
	};
} 

Vec3 rotateX(const Vec3& p, float angle) {
	float s = std::sin(angle);
	float c = std::cos(angle);
	return {
		p.x,
			p.y * c - p.z * s,
			p.y * s + p.z * c
	};
}

sf::Vector2f project(const Vec3& p) { //cam faces +X axis
	float scale = (WIDTH / 2.0f) / std::tan(FOV * 0.5f * 3.14159f / 180.0f);
	return {
		(p.x / p.z) * scale + WIDTH / 2.0f, //triangular similarity property
			(p.y / p.z) * scale + HEIGHT / 2.0f //convert normalized coords to screen coords
	};
}

int main() {
	sf::RenderWindow window(sf::VideoMode(WIDTH, HEIGHT), "sfml3D");
	window.setVerticalSyncEnabled(true);
    bool yD = false, xD = false;
    float totalY = 0.0f, totalX = 0.0f;
	Mesh myMesh = tetrahedron(1.0f);

	Vec3 cameraPos = {0, 0, -5};
	float yaw = 0.0f;
	float pitch = 0.0f;

	while (window.isOpen()) {
		sf::Event event;
		while (window.pollEvent(event)) {
			if (event.type == sf::Event::Closed)
				window.close();
		}
        
        const float rotationSpeed = 0.01f; //auto rotate
        if (!yD) {
            yaw += rotationSpeed;
            totalY += rotationSpeed;
            if (totalY >= 2 * 3.14159f) { yD = true; totalY = 0; } //2*pi 
        } else if (!xD) {
            pitch += rotationSpeed;
            totalX += rotationSpeed;
            if (totalX >= 2 * 3.14159f) { xD = true; totalX = 0; }
        } else {
            yaw = 0;
            pitch = 0;
            yD = false;
            xD = false;
        }

        window.clear();

		std::vector<std::tuple<Face, Vec3, Vec3, Vec3, float>> faceBuffer; //prep a render queue

		for (auto& face : myMesh.faces) { //loops over all faces
			Vec3 a = myMesh.verts[face.a];
			Vec3 b = myMesh.verts[face.b];
			Vec3 c = myMesh.verts[face.c];

			a = rotateX(rotateY(a, yaw),pitch);
			b = rotateX(rotateY(b, yaw),pitch);
			c = rotateX(rotateY(c, yaw),pitch);

			a = a - cameraPos;
			b = b - cameraPos;
			c = c - cameraPos;

			Vec3 u = b - a;
			Vec3 v = c - a;

			Vec3 normal = {   //cross prod of two edge vectors aka normal to surface
				u.y * v.z - u.z * v.y,
				u.z * v.x - u.x * v.z,
				u.x * v.y - u.y * v.x
			};

			Vec3 viewVec = {-a.x,-a.y,-a.z };

			if (viewVec.dot(normal) <= 0) continue; //face away from camera

			float avgZ = (a.z + b.z + c.z) / 3.0f; //avg z depth val
			faceBuffer.push_back({face, a, b, c, avgZ});
		}

		std::sort(faceBuffer.begin(), faceBuffer.end(), [](const auto& face1, const auto& face2) {
				return std::get<4>(face1) < std::get<4>(face2); //compares average Z of two faces
		}); //closer tris appear on top

		for (auto& [face, a, b, c, z] : faceBuffer) {
			if (a.z <= NEAR_PLANE || b.z <= NEAR_PLANE || c.z <= NEAR_PLANE) continue;

			sf::Vector2f pa = project(a);
			sf::Vector2f pb = project(b);
			sf::Vector2f pc = project(c);

            //vertex array prevents continous alloc and dealloc
			sf::VertexArray triangle(sf::Triangles, 3);
            triangle[0].position = pa;
            triangle[1].position = pb;
            triangle[2].position = pc;
            triangle[0].color = triangle[1].color = triangle[2].color = sf::Color(100, 100, 255);
            window.draw(triangle);

            sf::VertexArray edges(sf::LineStrip, 4);
            edges[0].position = pa;
            edges[1].position = pb;
            edges[2].position = pc;
            edges[3].position = pa;
            for (int i = 0; i < 4; ++i)
                edges[i].color = sf::Color::White;
                window.draw(edges);		
        }
		window.display();
	}
	return 0;
}

