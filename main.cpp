#include <SFML/Graphics.hpp>
#include <vector>
#include <cmath>
#include <algorithm>

const int WIDTH = 800; //4:3 ASPECT
const int HEIGHT = 600;
const float FOV = 53.0f;
const float NEAR_PLANE = 0.1f;

struct Vec3 {
    float x, y, z;
    Vec3 operator+(const Vec3& other) const {
        return {x + other.x, y + other.y, z + other.z};
    }
    Vec3 operator-(const Vec3& other) const {
        return {x - other.x, y - other.y, z - other.z};
    }
    Vec3 operator*(float s) const {
        return {x * s, y * s, z * s};
    }
};

struct Face {
    int a, b, c; //triangular projection
};

struct Mesh {
    std::vector<Vec3> verts; //vertices
    std::vector<Face> faces; 
};

Mesh tetrahedron(float size) { //will possibly import from external headers, in the future
    float s = size;
    Mesh mesh;
    mesh.verts = {                    //these coords have been generated by ChatGPT
        { 0, 0, s},                  
        { s, 0, -s / 2},             
        {-s, 0, -s / 2},             
        { 0, s, 0}                   
    };
    mesh.faces = {
        {0, 1, 2},
        {0, 3, 1},
        {1, 3, 2},
        {2, 3, 0}
    };

    return mesh;
}


Vec3 rotateY(const Vec3& p, float angle) {
    float s = std::sin(angle);
    float c = std::cos(angle);
    return { //too much to break down here
        p.x * c - p.z * s,
        p.y,
        p.x * s + p.z * c
    };
} 

Vec3 rotateX(const Vec3& p, float angle) {
    float s = std::sin(angle);
    float c = std::cos(angle);
    return {
        p.x,
        p.y * c - p.z * s,
        p.y * s + p.z * c
    };
}

sf::Vector2f project(const Vec3& p) { //cam faces +X axis
    float scale = (WIDTH / 2.0f) / std::tan(FOV * 0.5f * 3.14159f / 180.0f);
    return {
        (p.x / p.z) * scale + WIDTH / 2.0f, //triangular similarity property
        (p.y / p.z) * scale + HEIGHT / 2.0f //convert normalized coords to screen coords
    };
}

int main() {
    sf::RenderWindow window(sf::VideoMode(WIDTH, HEIGHT), "sfml3D");
    window.setFramerateLimit(60);
    
    Mesh myMesh = tetrahedron(1.0f);

    Vec3 cameraPos = {0, 0, -5};
    float yaw = 0.0f;
    float pitch = 0.0f;

    while (window.isOpen()) {
        sf::Event event;
        while (window.pollEvent(event)) {
            if (event.type == sf::Event::Closed)
                window.close();
        }
        //rotate cam
        if (sf::Keyboard::isKeyPressed(sf::Keyboard::Left)) yaw -= 0.03f; //MODIFY AS YOU WISH
        if (sf::Keyboard::isKeyPressed(sf::Keyboard::Right)) yaw += 0.03f;
        if (sf::Keyboard::isKeyPressed(sf::Keyboard::Up)) pitch -= 0.03f;
        if (sf::Keyboard::isKeyPressed(sf::Keyboard::Down)) pitch += 0.03f;

        Vec3 forward = { std::sin(yaw), 0, std::cos(yaw) };
        Vec3 right = { forward.z, 0, -forward.x };

        if (sf::Keyboard::isKeyPressed(sf::Keyboard::W)) cameraPos = cameraPos + forward * 0.1f;
        if (sf::Keyboard::isKeyPressed(sf::Keyboard::S)) cameraPos = cameraPos - forward * 0.1f;
        if (sf::Keyboard::isKeyPressed(sf::Keyboard::A)) cameraPos = cameraPos - right * 0.1f;
        if (sf::Keyboard::isKeyPressed(sf::Keyboard::D)) cameraPos = cameraPos + right * 0.1f;
        if (sf::Keyboard::isKeyPressed(sf::Keyboard::Space)) cameraPos.y += 0.1f;
        if (sf::Keyboard::isKeyPressed(sf::Keyboard::LShift)) cameraPos.y -= 0.1f;

        window.clear();

        for (auto& face : myMesh.faces) { //loops over all faces
            Vec3 a = myMesh.verts[face.a];
	    Vec3 b = myMesh.verts[face.b];
	    Vec3 c = myMesh.verts[face.c];

            a = rotateX(rotateY(a, yaw),pitch);
            b = rotateX(rotateY(b, yaw),pitch);
	    c = rotateX(rotateY(c, yaw),pitch);

            a = a - cameraPos;
            b = b - cameraPos;
	    c = c - cameraPos;

            if (a.z <= NEAR_PLANE || b.z <= NEAR_PLANE || c.z <= NEAR_PLANE) continue; //OTHERWISE SKIP

            sf::Vector2f pa = project(a);
            sf::Vector2f pb = project(b);
	    sf::Vector2f pc = project(c);

	    sf::ConvexShape triangle;
	    triangle.setPointCount(3);
	    triangle.setPoint(0,pa);
	    triangle.setPoint(1,pb);
	    triangle.setPoint(2,pc);
	    triangle.setFillColor(sf::Color(100,100,255)); //light blue

	    window.draw(triangle);
	    //the following manually draws in edges
	    sf::Vertex line1[] = { sf::Vertex(pa, sf::Color::White), sf::Vertex(pb, sf::Color::White) };
            sf::Vertex line2[] = { sf::Vertex(pb, sf::Color::White), sf::Vertex(pc, sf::Color::White) };
            sf::Vertex line3[] = { sf::Vertex(pc, sf::Color::White), sf::Vertex(pa, sf::Color::White) };
            window.draw(line1, 2, sf::Lines);
            window.draw(line2, 2, sf::Lines);
            window.draw(line3, 2, sf::Lines);
        }
        window.display();
    }
    return 0;
}

